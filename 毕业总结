    经过这一段时间的学习，是我基本掌握了做题的步骤，遇到问题不在慌张，按照老师教的。
        首先，审题、审题、审题。
        其次，不明白的地方一定要问清楚了。
        然后，想清楚做题步骤和时间复杂度等，选用最好的时间复杂度去做题。

    当然，学习不只是为了面试的，最主要的还是学习编程的内功，算法和数据结构是相当重要的一部分，想要成长，这一部分就必须要掌握。比如，同样的一段代码你可以在使用O(n)的时间复杂度和最小的空间复杂度完成，那么你的程序就是最优的程序。这就需要不断的学习下去。
    在本期学习中主要学到了：
        一、做题技巧
            五毒神掌
        二、最大误区
            刷题只刷一遍，当时可能会了，过一段时间可能就会忘记
        三、核心思想
            升维
            空间换时间
        四、类型
            跳表
            优先队列
            堆
                最大堆
                最小堆
                常见的堆的二叉堆、斐波那契堆等
            栈
            队列
            树
                二叉树、多叉树、搜索树、AVL、红黑树
                常见算法
                    前、中、后 排序
                    搜索树查找、验证
                    递归
                        分治和回溯
                        思维要点：
                            1、不要人肉进行递归
                            2、找到最近最简的子问题
                            3、数学归纳法思维
            图
                表示
                    邻接矩阵
                    邻接表
                    无向无权图
                    有向无权图
                    无向有权图
                常见算法
                    跟树的最大区别是一定要加 visited，因为会有环
                    DFS
                    BFS
                    双端BFS
        五、其他算法
            贪心算法
                贪心算法是一种在每一步选择中都采取在当下状态下最好或最优的选择，从而希望导致结果是全局最好或最优的算法
                与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退何种情况下可以使用贪心算法
            动态规划
                1、最优子结构 opt[n] = best_of(opt[n-1],opt[n-2],...)
                2、存储中间状态:opt[i]
                3、递推公式 (美其名曰：状态转移方程或者DP方程)
                    Fib:opt[i] = opt[n-1]+opt[n-2]
                    二维路径：opt[i,j] = opt[i+1][j]+opt[i][j+1] (且判断a[i,j]是否空地)
                动态规划小结：
                    1、打破自己的思维惯性，形成机器思维
                    2、理解复杂逻辑关键
                    3、也是职业进阶的要点要领
            位运算
            排序
                1、比较类排序
                    时间复杂度不能突破 O(nlogn)
                    交换排序
                    插入排序
                    选择排序
                    归并排序
                2、非比较类排序
                    对于整型
                    可以达到 O(n+k)
                    计数排序
                    桶排序
                        与计数排序的区别，计数排序是对应的下标是有序的连续的下标的桶排序
                        桶排序是有一个函数要计算桶的下标，可以理解为计数排序的升级版
                    基数排序
                初级排序O(n^2)
                    1、选择排序
                        每次找最小值，然后放到待排序数组的起始位置
                    2、插入排序
                        从前到后逐步构建有序序列；对于未排序数据，在已排序序列中从后向前扫描，找到响应位置并插入
                    3、冒泡排序
                        嵌套循环，每次查看相邻的元素如果逆序，则交换
                高级排序 O(nlogn)
                    快速排序
                        数组取标杆pivot，将小元素放pivot左边，大元素方右侧，然后依次对右边和左边子数组继续排序；以达到整个序列有序
                    归并排序 --分治
                        1、把长度为n的输入序列分成两个长度为n/2的子序列
                        2、对这两个子序列分别采用归并排序
                        3、将两个排好序的子序列合并成一个最终的排序序列
                    归并和快排具有相似性，但步骤顺序相反
                        归并：先排序左右子数组，然后合并两个有序子数组
                        快排：想调配出左右子数组，然后对左右子数组进行排序
                    堆排序：
                        堆插入 O(logn),取最大值/小值 O(1)
                        1、数组元素依次建立小顶堆
                        2、依次取堆顶元素，并删除
            字典树
            并查集
            启发式搜索(A*)
            字符串算法
                1、暴力法 - O(MN)
                2、Rabin-Karp 算法
                3、KMP 算法
                4、Boyer-Moore 算法
                5、Sunday 算法
    除了之上的知识点还有很多很多，就需要自己接下来沉淀一下，争取每天都进步一点
