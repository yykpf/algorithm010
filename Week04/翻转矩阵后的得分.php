<?php
// 861. 翻转矩阵后的得分
// 有一个二维矩阵 A 其中每个元素的值为 0 或 1 。

// 移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。

// 在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。

// 返回尽可能高的分数。

// 示例：

// 输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]
// 输出：39
// 解释：
// 转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]
// 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39

// 提示：
// 1 <= A.length <= 20
// 1 <= A[0].length <= 20
// A[i][j] 是 0 或 1

class Solution {

    /**
     * @param Integer[][] $A
     * @return Integer
     */
    function matrixScore($A) {
        $m = count($A);
        $n = count($A[0]);
        // 第一列默认全是1 才是最大值，那么第一列的总分值是(每一行的二进制相加比如三列三行：bindec('100') * 3)：
        $ret = $m * (1 << ($n - 1));
        for ($j=1; $j < $n; $j++) {
            $nOns = 0;
            for ($i=0; $i < $m; $i++) {
                if ($A[$i][0] == 1) {
                    $nOns += $A[$i][$j];
                } else {
                    $nOns += (1 - $A[$i][$j]); // 如果当前行的第一不为1，那就证明这一行需要反转
                }
            }
            $k = max($nOns, $m - $nOns);
            $ret += ($k * (1 << ($n - $j -1)));
        }
        return $ret;
    }
}
$A = [
    [0,0,1,1],
    [1,0,1,0],
    [1,1,0,0]
    ];
$n = new Solution();
echo $n->matrixScore($A);